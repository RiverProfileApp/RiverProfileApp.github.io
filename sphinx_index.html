
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

    <title>Welcome to Profiler’s documentation! &#8212; Profiler 0.11 documentation</title>
    <link rel="stylesheet" href="_static/haiku.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/language_data.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" /> 
  </head><body>
      <div class="header" role="banner"><h1 class="heading"><a href="#">
          <span>Profiler 0.11 documentation</span></a></h1>
        <h2 class="heading"><span>Welcome to Profiler’s documentation!</span></h2>
      </div>
      <div class="topnav" role="navigation" aria-label="top navigation">
      
        <p>
        <a class="uplink" href="#">Contents</a>
        </p>

      </div>
      <div class="content" role="main">
        
        
  <section id="module-profiler_app">
<span id="welcome-to-profiler-s-documentation"></span><h1>Welcome to Profiler’s documentation!<a class="headerlink" href="#module-profiler_app" title="Permalink to this headline">¶</a></h1>
<dl class="py function">
<dt id="profiler_app.boxplots">
<code class="sig-prename descclassname">profiler_app.</code><code class="sig-name descname">boxplots</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#profiler_app.boxplots" title="Permalink to this definition">¶</a></dt>
<dd><p>This is an example code to show how to take in variables generated by the app during upstream and downstream querying
and then applying a custom function, in this case returning a box plot of elevations sorted by drinage areas as a png figure</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>boxplot figure, binned acc vs elevation</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="profiler_app.chiplot">
<code class="sig-prename descclassname">profiler_app.</code><code class="sig-name descname">chiplot</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#profiler_app.chiplot" title="Permalink to this definition">¶</a></dt>
<dd><p>This main chi plot is done primarily by Altair.  This calculates chi from acc and dist vectors,
converts chi - elevation data into a Pandas dataframe, and returns it as html script via the to_html function built
into Altair</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>chi - elevation interactive plot</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="profiler_app.chiplot_multi">
<code class="sig-prename descclassname">profiler_app.</code><code class="sig-name descname">chiplot_multi</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#profiler_app.chiplot_multi" title="Permalink to this definition">¶</a></dt>
<dd><p>Chi plots for upstream mode. Altair does not play well with the many chi-elevation plots, so this takes the
chi-elevation data and converts it to a format which can then by processed by d3 in the chi_multi.html page.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>chi - elevation interactive plot</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="profiler_app.getA">
<code class="sig-prename descclassname">profiler_app.</code><code class="sig-name descname">getA</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">dir1</span></em>, <em class="sig-param"><span class="n">ny</span></em>, <em class="sig-param"><span class="n">code</span></em>, <em class="sig-param"><span class="n">dx</span></em><span class="sig-paren">)</span><a class="headerlink" href="#profiler_app.getA" title="Permalink to this definition">¶</a></dt>
<dd><p>Get and cache the accumulation (linear) values along stream</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dir1</strong> – directory containing files</p></li>
<li><p><strong>ny</strong> – y dimensions</p></li>
<li><p><strong>code</strong> – code for caching</p></li>
<li><p><strong>dx</strong> – x resolution at this latitude</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>accumulation (linear) along stream</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="profiler_app.get_acc">
<code class="sig-prename descclassname">profiler_app.</code><code class="sig-name descname">get_acc</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#profiler_app.get_acc" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the accumulation grids to download - just a simple call to getA.  This can be done by a direct call to the cache also</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Acc to download</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="profiler_app.get_chi">
<code class="sig-prename descclassname">profiler_app.</code><code class="sig-name descname">get_chi</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#profiler_app.get_chi" title="Permalink to this definition">¶</a></dt>
<dd><p>This will get the chi values only if a chi plot has already been generated (in downstram mode).  A chi plot does not need to be
generated in upstream mode.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>chi values to download</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="profiler_app.get_dist">
<code class="sig-prename descclassname">profiler_app.</code><code class="sig-name descname">get_dist</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#profiler_app.get_dist" title="Permalink to this definition">¶</a></dt>
<dd><p>Download distance array
Please note units for dist used to be degrees in previous versions of the app, changed to the more standard (meters)</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Distance to download</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="profiler_app.get_elev">
<code class="sig-prename descclassname">profiler_app.</code><code class="sig-name descname">get_elev</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#profiler_app.get_elev" title="Permalink to this definition">¶</a></dt>
<dd><p>Getter for elevation data.  This is done by a call to getz(), which returns smoothed data (in downstream mode) if available.
otherwise, it returns the raw data.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Get elevation to download</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="profiler_app.get_profiles">
<code class="sig-prename descclassname">profiler_app.</code><code class="sig-name descname">get_profiles</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#profiler_app.get_profiles" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the location and elevation, drainage area, and other derivative information of stream profiles.
This is the main driver function of RiverProfileApp.  Ultimately the all of the base functionaility is called from here, including
downstream and upstream querying of rivers. The function assigns a code to a user which determines their “session”
Importantly, several variables are saved in the cache by get_profiles which can then be used by subsequent calls to functions under a given session.
These variables are</p>
<p>acc: Drainage accumulation.  In upstream mode, individual rivers are separated by NaN
dist: Distance downstream
z: Raw elevation
zfilt: Filtered elevation</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>elevations and locations of stream(s) rendered on main page</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="profiler_app.get_shp">
<code class="sig-prename descclassname">profiler_app.</code><code class="sig-name descname">get_shp</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#profiler_app.get_shp" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates a shapefile from the river network.  This uses basic functionality of geopandas.  In reality it returns it in
geojson format, but due to lack of familiarity with that format the name of the function reflects shapefile, which more people
are probably familiar with</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>geojson - a bit misleading but name is descriptive</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="profiler_app.getz">
<code class="sig-prename descclassname">profiler_app.</code><code class="sig-name descname">getz</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">dir1</span></em>, <em class="sig-param"><span class="n">ny</span></em>, <em class="sig-param"><span class="n">code</span></em>, <em class="sig-param"><span class="n">smooth</span><span class="o">=</span><span class="default_value">- 1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#profiler_app.getz" title="Permalink to this definition">¶</a></dt>
<dd><p>Get and store elevation values along stream.  If available, smoothed z values are automatically returned.  Otherwise, raw z values.
If no raw z values are available, the function checks if the “strm” index variable has been set and collects z values directly from DEM.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dir1</strong> – </p></li>
<li><p><strong>ny</strong> – </p></li>
<li><p><strong>code</strong> – </p></li>
<li><p><strong>smooth</strong> – smoothing wl in pixel</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>z values, smoothed</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="profiler_app.main">
<code class="sig-prename descclassname">profiler_app.</code><code class="sig-name descname">main</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#profiler_app.main" title="Permalink to this definition">¶</a></dt>
<dd><p>Main page.  This is more or less a function for simple redirection to the main page.  But, it also initiates some important variables
such as basin_extract (aka, upstream mode option) as well as d8 (unconditioned d8 option), and theta (for upstream mode chi plots).</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>rendered main page, no streams assigned yet (main page flag is 1)</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="profiler_app.other_functions">
<code class="sig-prename descclassname">profiler_app.</code><code class="sig-name descname">other_functions</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#profiler_app.other_functions" title="Permalink to this definition">¶</a></dt>
<dd><p>This routes to the other_functions html page for convenience</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>other_functions.html, which is intentionally simplified.  Only the user code is passed</p>
</dd>
</dl>
</dd></dl>

<span class="target" id="module-profiler_functions"></span><dl class="py function">
<dt id="profiler_functions.calc_upstream">
<code class="sig-prename descclassname">profiler_functions.</code><code class="sig-name descname">calc_upstream</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">i</span></em>, <em class="sig-param"><span class="n">j</span></em>, <em class="sig-param"><span class="n">sx</span></em>, <em class="sig-param"><span class="n">sy</span></em>, <em class="sig-param"><span class="n">dem</span></em>, <em class="sig-param"><span class="n">acc</span></em>, <em class="sig-param"><span class="n">dx</span><span class="o">=</span><span class="default_value">90</span></em>, <em class="sig-param"><span class="n">athres</span><span class="o">=</span><span class="default_value">50</span></em>, <em class="sig-param"><span class="n">theta</span><span class="o">=</span><span class="default_value">0.45</span></em><span class="sig-paren">)</span><a class="headerlink" href="#profiler_functions.calc_upstream" title="Permalink to this definition">¶</a></dt>
<dd><dl>
<dt>takes the input flowdir indices sx sy and makes the topologically ordered</dt><dd><p>stack of the stream network in O(n) time.  It also gathers elevation and topography data, and calculates chi based on the input theta value.
The FastScape method does not properly order streams to be continuous, which is needed for plotting</p>
<blockquote>
<div><p>so stream indices are re-arranged after the fastscape method is employed.  Ideally the fastscape algorithm would be separated from these other
calculations (so that we could have a separate (stack() function), but I could not think of an efficient way to decouple these other calculations</p>
<blockquote>
<div><p>from the stack calculation</p>
</div></blockquote>
</div></blockquote>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sx</strong> – x flow direction grid</p></li>
<li><p><strong>sy</strong> – y flow direction grid</p></li>
<li><p><strong>dem</strong> – input dem (mem-mapped)</p></li>
<li><p><strong>acc</strong> – drainage accumulation</p></li>
<li><p><strong>dx</strong> – x distance between cells</p></li>
<li><p><strong>athres</strong> – threshold for drainage area (minimum 10)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>topologically ordered stack, I</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="profiler_functions.chicalc">
<code class="sig-prename descclassname">profiler_functions.</code><code class="sig-name descname">chicalc</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">A</span></em>, <em class="sig-param"><span class="n">dist</span></em>, <em class="sig-param"><span class="n">theta</span></em>, <em class="sig-param"><span class="n">U</span><span class="o">=</span><span class="default_value">1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#profiler_functions.chicalc" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates chi values for linear stream (downstream mode).  Relatively trivial but used frequently, so makes sense
to have a stand-alone function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>A</strong> – Accumulation (linear) along stream</p></li>
<li><p><strong>dist</strong> – distance (linear) along stream</p></li>
<li><p><strong>theta</strong> – aka concavity</p></li>
<li><p><strong>U</strong> – If we have variable uplift</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>linear chi values along stream</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="profiler_functions.find_nearest_thresarea">
<code class="sig-prename descclassname">profiler_functions.</code><code class="sig-name descname">find_nearest_thresarea</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">il</span></em>, <em class="sig-param"><span class="n">jl</span></em>, <em class="sig-param"><span class="n">acc</span></em>, <em class="sig-param"><span class="n">tol</span><span class="o">=</span><span class="default_value">10</span></em><span class="sig-paren">)</span><a class="headerlink" href="#profiler_functions.find_nearest_thresarea" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds the largest drainage area within a given box of specified km around the center at (il, jl) (“snapping”).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>il</strong> – initial y coordinate</p></li>
<li><p><strong>jl</strong> – initial x coordinate</p></li>
<li><p><strong>acc</strong> – accumulation grid</p></li>
<li><p><strong>tol</strong> – tolerance (in units of cells) that defines the size of box</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>coordinates of max. drainage area within the box</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="profiler_functions.getstream_elev">
<code class="sig-prename descclassname">profiler_functions.</code><code class="sig-name descname">getstream_elev</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">i</span></em>, <em class="sig-param"><span class="n">j</span></em>, <em class="sig-param"><span class="n">stackx</span></em>, <em class="sig-param"><span class="n">stacky</span></em>, <em class="sig-param"><span class="n">dem</span></em>, <em class="sig-param"><span class="n">elev</span><span class="o">=</span><span class="default_value">0</span></em><span class="sig-paren">)</span><a class="headerlink" href="#profiler_functions.getstream_elev" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the indices from the receiver grids, until a given elevation
(this is redundant, one of these should be replaced in the future)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>i</strong> – input initial index i</p></li>
<li><p><strong>j</strong> – input initial index j</p></li>
<li><p><strong>stackx</strong> – x receiver grid</p></li>
<li><p><strong>stacky</strong> – y receiver grid</p></li>
<li><p><strong>elev</strong> – elevation above which to profile to</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>linear index of stream locations on the grid</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="profiler_functions.lind">
<code class="sig-prename descclassname">profiler_functions.</code><code class="sig-name descname">lind</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">xy</span></em>, <em class="sig-param"><span class="n">n</span></em><span class="sig-paren">)</span><a class="headerlink" href="#profiler_functions.lind" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute linear index from 2 points</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>xy</strong> – linear index</p>
</dd>
<dt class="field-even">N<span class="colon">:</span></dt>
<dd class="field-even"><p>number of values in y dimension (or the number of values per row)</p>
</dd>
</dl>
</dd></dl>

<span class="target" id="module-globalstack_functions"></span><dl class="py function">
<dt id="globalstack_functions.acc">
<code class="sig-prename descclassname">globalstack_functions.</code><code class="sig-name descname">acc</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">sx</span></em>, <em class="sig-param"><span class="n">sy</span></em>, <em class="sig-param"><span class="n">Ix</span></em>, <em class="sig-param"><span class="n">Iy</span></em>, <em class="sig-param"><span class="n">size</span></em><span class="sig-paren">)</span><a class="headerlink" href="#globalstack_functions.acc" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes the stack and receiver grids and computes drainage area.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sx</strong> – x flow direction grid</p></li>
<li><p><strong>sy</strong> – y flow direction grid</p></li>
<li><p><strong>Ix</strong> – x flow direction grid</p></li>
<li><p><strong>Iy</strong> – y flow direction grid</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Drainage area grid</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="globalstack_functions.h_flowdir">
<code class="sig-prename descclassname">globalstack_functions.</code><code class="sig-name descname">h_flowdir</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">d</span></em><span class="sig-paren">)</span><a class="headerlink" href="#globalstack_functions.h_flowdir" title="Permalink to this definition">¶</a></dt>
<dd><p>Translate flow dir from hydrosheds into flow dir from simplem format.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>d</strong> – flow direction grid from hydrosheds</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>sx and sy, the flow direction in x and y directions ( i.e. -1, 0 , 1)</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="globalstack_functions.lind">
<code class="sig-prename descclassname">globalstack_functions.</code><code class="sig-name descname">lind</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">xy</span></em>, <em class="sig-param"><span class="n">n</span></em><span class="sig-paren">)</span><a class="headerlink" href="#globalstack_functions.lind" title="Permalink to this definition">¶</a></dt>
<dd><p>compute bilinear index from linear indices - trivial but widely used (hence the separate function)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xy</strong> – linear index</p></li>
<li><p><strong>n</strong> – ny or nx (depending on row-major or col-major indexing)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="globalstack_functions.sinkfill">
<code class="sig-prename descclassname">globalstack_functions.</code><code class="sig-name descname">sinkfill</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">Z</span></em><span class="sig-paren">)</span><a class="headerlink" href="#globalstack_functions.sinkfill" title="Permalink to this definition">¶</a></dt>
<dd><p>Fill pits using the priority flood method of Barnes et al., 2014.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>Z</strong> – Input elevation grid</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>output elevation, pit filled</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="globalstack_functions.slp">
<code class="sig-prename descclassname">globalstack_functions.</code><code class="sig-name descname">slp</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">Z</span></em><span class="sig-paren">)</span><a class="headerlink" href="#globalstack_functions.slp" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the flow direction receiver grid of a DEM based on the D8 algorithm</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Flow direction receiver grid values sy and sx ( both D8 directions -1,0,1)</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="globalstack_functions.stack_bilinear">
<code class="sig-prename descclassname">globalstack_functions.</code><code class="sig-name descname">stack_bilinear</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">sx</span></em>, <em class="sig-param"><span class="n">sy</span></em><span class="sig-paren">)</span><a class="headerlink" href="#globalstack_functions.stack_bilinear" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>takes the input flordirs sx sy and makes the topologically ordered</dt><dd><p>stack of the stream network in O(n) time.  This is a slightly different approach from the
Fastscape algorithm which uses a recursive function - instead this sues a while loop, which is more efficient.
The bilinear indices use less memory than the linear indices.  In memory limited systems, that is important, and that is why it is done here</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sx</strong> – x flow direction grid</p></li>
<li><p><strong>sy</strong> – y flow direction grid</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>topologically ordered stack, Ix and Iy indices</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="globalstack_functions.zero_edges">
<code class="sig-prename descclassname">globalstack_functions.</code><code class="sig-name descname">zero_edges</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">y</span></em><span class="sig-paren">)</span><a class="headerlink" href="#globalstack_functions.zero_edges" title="Permalink to this definition">¶</a></dt>
<dd><p>Trivial but widely used function to zero out edges of a matrix</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>y</strong> – input matrix</p>
</dd>
</dl>
<p>“returns: Matrix with edges zeroed out</p>
</dd></dl>

<div class="toctree-wrapper compound">
</div>
</section>
<section id="indices-and-tables">
<h1>Indices and tables<a class="headerlink" href="#indices-and-tables" title="Permalink to this headline">¶</a></h1>
<ul class="simple">
<li><p><a class="reference internal" href="genindex.html"><span class="std std-ref">Index</span></a></p></li>
<li><p><a class="reference internal" href="py-modindex.html"><span class="std std-ref">Module Index</span></a></p></li>
<li><p><a class="reference internal" href="search.html"><span class="std std-ref">Search Page</span></a></p></li>
</ul>
</section>


      </div>
      <div class="bottomnav" role="navigation" aria-label="bottom navigation">
      
        <p>
        <a class="uplink" href="#">Contents</a>
        </p>

      </div>

    <div class="footer" role="contentinfo">
        &#169; Copyright 2022, GR.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 3.2.1.
    </div>
  </body>
</html>